type VftUserInfo = 
 record {
   details: text;
   nft: opt Nft;
   task_code: text;
   userId: text;
   vft_total: float64;
   wallet: opt text;
 };
type TransformArgs = 
 record {
   context: blob;
   response: HttpResponsePayload;
 };
type TokenId = nat64;
type Nft = 
 record {
   from: principal;
   id: TokenId;
   meta: MetadataDesc;
   op: text;
   owner: principal;
   tid: nat;
   to: principal;
 };
type MetadataVal = 
 variant {
   BlobContent: blob;
   Nat16Content: nat16;
   Nat32Content: nat32;
   Nat64Content: nat64;
   Nat8Content: nat8;
   NatContent: nat;
   TextContent: text;
 };
type MetadataPurpose = 
 variant {
   Preview;
   Rendered;
 };
type MetadataPart = 
 record {
   data: blob;
   key_val_data: vec MetadataKeyVal;
   purpose: MetadataPurpose;
 };
type MetadataKeyVal = 
 record {
   key: text;
   val: MetadataVal;
 };
type MetadataDesc = vec MetadataPart;
type HttpResponsePayload = 
 record {
   body: vec nat8;
   headers: vec HttpHeader;
   status: nat;
 };
type HttpHeader = 
 record {
   name: text;
   value: text;
 };
type CanisterHttpResponsePayload = 
 record {
   body: vec nat8;
   headers: vec HttpHeader;
   status: nat;
 };
service : {
  TextToNat2: (text) -> (float64);
  cleanAll: (nat, nat) -> (text);
  queryLastIndex: () -> (nat) query;
  queryRecordCount: () -> (nat) query;
  queryUserInfoEntry: () -> (vec record {
                                   text;
                                   VftUserInfo;
                                 }) query;
  transform: (TransformArgs) -> (CanisterHttpResponsePayload) query;
  work: () -> ();
}
